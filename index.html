<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>表盘番茄钟 - 大声循环闹钟 + 弹窗提醒</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; }
    button:focus { outline: none; }
  </style>
</head>
<body class="bg-neutral-100">
  <div id="root"></div>
  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    const Ctx = React.createContext(null);

    function App() {
      return (
        <AlarmProvider>
          <div className="min-h-screen w-full flex items-center justify-center p-6">
            <div className="w-full max-w-[880px] grid md:grid-cols-[420px_1fr] gap-8 items-center">
              <DialTimer />
              <Controls />
            </div>
          </div>
          <AlarmModal />
        </AlarmProvider>
      );
    }

    function AlarmProvider({ children }) {
      const [remainingSec, setRemainingSec] = useState(25 * 60);
      const [running, setRunning] = useState(false);
      const [alarmActive, setAlarmActive] = useState(false);
      const [alarmVolume, setAlarmVolume] = useState(1.0); // 0..1
      const startedAtRef = useRef(null);
      const pausedRemainRef = useRef(remainingSec);
      const tickRef = useRef(null);

      // WebAudio nodes
      const audioCtxRef = useRef(null);
      const alarmIntervalRef = useRef(null);
      const masterGainRef = useRef(null);

      const ensureAudioContext = () => {
        if (!audioCtxRef.current) {
          const AudioCtx = window.AudioContext || window.webkitAudioContext;
          audioCtxRef.current = new AudioCtx();
          masterGainRef.current = audioCtxRef.current.createGain();
          masterGainRef.current.gain.value = alarmVolume;
          masterGainRef.current.connect(audioCtxRef.current.destination);
        } else {
          audioCtxRef.current.resume?.();
        }
      };

      const clearTick = () => {
        if (tickRef.current) cancelAnimationFrame(tickRef.current);
        tickRef.current = null;
      };

      const start = () => {
        if (running) return;
        setRunning(true);
        const now = Date.now();
        startedAtRef.current = now;

        const loop = () => {
          const startedAt = startedAtRef.current;
          if (!startedAt) return;
          const elapsed = Math.floor((Date.now() - startedAt) / 1000);
          const next = Math.max(pausedRemainRef.current - elapsed, 0);
          setRemainingSec(next);
          if (next <= 0) {
            setRunning(false);
            clearTick();
            startedAtRef.current = null;
            pausedRemainRef.current = 0;
            triggerAlarm();
            return;
          }
          tickRef.current = requestAnimationFrame(loop);
        };
        tickRef.current = requestAnimationFrame(loop);
      };

      const pause = () => {
        if (!running) return;
        setRunning(false);
        clearTick();
        startedAtRef.current = null;
        pausedRemainRef.current = remainingSec;
      };

      const reset = (toSec = 25 * 60) => {
        setRunning(false);
        clearTick();
        setRemainingSec(toSec);
        pausedRemainRef.current = toSec;
        startedAtRef.current = null;
      };

      const addFive = () => {
        const added = Math.min(60 * 60, remainingSec + 5 * 60);
        setRemainingSec(added);
        pausedRemainRef.current = added;
      };

      const setByMinutes = (minutes) => {
        const m = Math.max(1, Math.min(60, minutes || 60));
        reset(m * 60);
      };

      const setVolume = (v) => {
        const vol = Math.max(0, Math.min(1, v));
        setAlarmVolume(vol);
        if (masterGainRef.current) masterGainRef.current.gain.value = vol;
      };

      const triggerAlarm = async () => {
        setAlarmActive(true);
        ensureAudioContext();
        startAlarmLoop();
        try {
          if ("Notification" in window) {
            if (Notification.permission === "granted") {
              new Notification("番茄钟：时间到了！", { body: "点击这里返回页面停止闹钟", requireInteraction: true });
            } else if (Notification.permission !== "denied") {
              const perm = await Notification.requestPermission();
              if (perm === "granted") {
                new Notification("番茄钟：时间到了！", { body: "点击这里返回页面停止闹钟", requireInteraction: true });
              }
            }
          }
        } catch {}
      };

      const stopAlarm = () => {
        setAlarmActive(false);
        stopAlarmLoop();
      };

      const startAlarmLoop = () => {
        stopAlarmLoop();
        ensureAudioContext();
        const ctx = audioCtxRef.current;
        const master = masterGainRef.current;
        const playPattern = () => {
          if (!ctx) return;
          beepOnce(ctx, master, 0, 1000);
          beepOnce(ctx, master, 0.35, 1200);
        };
        playPattern();
        alarmIntervalRef.current = setInterval(playPattern, 1200);
      };

      const stopAlarmLoop = () => {
        if (alarmIntervalRef.current) {
          clearInterval(alarmIntervalRef.current);
          alarmIntervalRef.current = null;
        }
      };

      useEffect(() => () => {
        clearTick();
        stopAlarmLoop();
        if (audioCtxRef.current) {
          audioCtxRef.current.close();
          audioCtxRef.current = null;
          masterGainRef.current = null;
        }
      }, []);

      const mm = String(Math.floor(remainingSec / 60)).padStart(2, "0");
      const ss = String(Math.floor(remainingSec % 60)).padStart(2, "0");

      const store = {
        remainingSec, running, alarmActive, alarmVolume, mm, ss,
        start, pause, reset, addFive, setByMinutes, setVolume, stopAlarm,
      };
      return <Ctx.Provider value={store}>{children}</Ctx.Provider>;
    }

    function beepOnce(ctx, masterGain, offsetSec, freq = 1000) {
      const now = ctx.currentTime + offsetSec;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(0.9, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(now);
      osc.stop(now + 0.32);
    }

    function DialTimer() {
      const { remainingSec, setByMinutes } = React.useContext(Ctx);
      const size = 420;
      const cx = size / 2;
      const cy = size / 2;
      const r = size * 0.42;
      const ringR = r * 0.98;

      const remainingMinutesForDial = Math.min(remainingSec / 60, 60);

      const sectorPath = React.useMemo(() => {
        const sweepAngle = (remainingMinutesForDial / 60) * 360;
        if (sweepAngle <= 0) return "";
        const startAngle = -90;
        const endAngle = startAngle + sweepAngle;
        const toXY = (angleDeg) => {
          const rad = (angleDeg * Math.PI) / 180;
          return { x: cx + r * Math.cos(rad), y: cy + r * Math.sin(rad) };
        };
        const p1 = toXY(startAngle);
        const p2 = toXY(endAngle);
        const largeArc = sweepAngle > 180 ? 1 : 0;
        return `M ${cx} ${cy} L ${p1.x} ${p1.y} A ${r} ${r} 0 ${largeArc} 1 ${p2.x} ${p2.y} Z`;
      }, [remainingMinutesForDial, cx, cy, r]);

      const pointerPath = React.useMemo(() => {
        const sweepAngle = (remainingMinutesForDial / 60) * 360;
        const endAngle = -90 + sweepAngle;
        const rad = (endAngle * Math.PI) / 180;
        const px = cx + r * Math.cos(rad);
        const py = cy + r * Math.sin(rad);
        return `M ${cx} ${cy} L ${px} ${py}`;
      }, [remainingMinutesForDial, cx, cy, r]);

      const ticks = React.useMemo(() => {
        const list = [];
        const labels = ["0/60", "5", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55"];
        const step = 360 / 12;
        for (let i = 0; i < labels.length; i++) {
          const angle = -90 + step * i;
          const rad = (angle * Math.PI) / 180;
          const x = cx + ringR * Math.cos(rad);
          const y = cy + ringR * Math.sin(rad);
          list.push({ label: labels[i], x, y, key: labels[i] + i });
        }
        return list;
      }, [cx, cy, ringR]);

      const handleDialClick = (e) => {
        const svg = e.currentTarget;
        const rect = svg.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > r * 1.1) return;
        const deg = Math.atan2(dy, dx) * 180 / Math.PI;
        let cw = (deg + 90);
        cw = (cw + 360) % 360;
        let mins = Math.round(cw / 6);
        if (mins === 0) mins = 60;
        setByMinutes(mins);
      };

      return (
        <div className="bg-white rounded-2xl shadow-lg p-4 flex items-center justify-center select-none">
          <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`} onClick={handleDialClick} className="cursor-pointer">
            <circle cx={cx} cy={cy} r={r} fill="#ffffff" stroke="#e5e7eb" strokeWidth={4} />
            {sectorPath && <path d={sectorPath} fill="#fca5a5" opacity={0.9} />}
            <path d={pointerPath} stroke="#111827" strokeWidth={6} strokeLinecap="round" />
            <circle cx={cx} cy={cy} r={6} fill="#111827" />
            {Array.from({ length: 60 }).map((_, i) => {
              const angle = (-90 + i * 6) * (Math.PI / 180);
              const outer = r;
              const inner = r - (i % 5 === 0 ? 14 : 8);
              const x1 = cx + outer * Math.cos(angle);
              const y1 = cy + outer * Math.sin(angle);
              const x2 = cx + inner * Math.cos(angle);
              const y2 = cy + inner * Math.sin(angle);
              return <line key={i} x1={x1} y1={y1} x2={x2} y2={y2} stroke="#9ca3af" strokeWidth={i % 5 === 0 ? 2 : 1} />;
            })}
            {ticks.map((t) => (
              <text key={t.key} x={t.x} y={t.y} textAnchor="middle" dominantBaseline="central" fontSize={16} fill="#111827">
                {t.label}
              </text>
            ))}
          </svg>
        </div>
      );
    }

    function Controls() {
      const { running, start, pause, reset, addFive, mm, ss, alarmVolume, setVolume } = React.useContext(Ctx);
      return (
        <div className="bg-white rounded-2xl shadow-lg p-6 flex flex-col gap-6">
          <div>
            <div className="text-sm text-neutral-500">剩余时间</div>
            <div className="text-6xl font-semibold tracking-wider tabular-nums">{mm}:{ss}</div>
          </div>
          <div className="flex items-center gap-3 flex-wrap">
            {!running ? (
              <button onClick={start} className="px-5 py-3 rounded-xl bg-black text-white shadow hover:opacity-90">开始</button>
            ) : (
              <button onClick={pause} className="px-5 py-3 rounded-xl bg-neutral-800 text-white shadow hover:opacity-90">暂停</button>
            )}
            <button onClick={() => reset()} className="px-5 py-3 rounded-xl bg-neutral-200 hover:bg-neutral-300">重置</button>
            <button onClick={addFive} className="px-5 py-3 rounded-xl bg-rose-100 text-rose-700 hover:bg-rose-200">+5 分钟</button>
          </div>

          <div className="grid gap-2">
            <label className="text-sm text-neutral-600">闹钟音量（更大声）</label>
            <div className="flex items-center gap-3">
              <input type="range" min="0" max="1" step="0.01" value={alarmVolume} onChange={(e) => setVolume(parseFloat(e.target.value))} className="w-full" />
              <div className="w-12 text-right tabular-nums">{Math.round(alarmVolume*100)}%</div>
            </div>
          </div>
        </div>
      );
    }

    function AlarmModal() {
      const { alarmActive, stopAlarm } = React.useContext(Ctx);
      if (!alarmActive) return null;
      return (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/50 backdrop-blur-sm"></div>
          <div className="absolute inset-0 flex items-center justify-center p-4">
            <div className="bg-white w-full max-w-md rounded-2xl shadow-2xl p-6 text-center">
              <div className="text-2xl font-semibold">时间到！</div>
              <div className="mt-2 text-neutral-600">闹钟正在循环播放，点击下方按钮停止</div>
              <button onClick={stopAlarm} className="mt-6 px-6 py-3 rounded-xl bg-rose-600 text-white font-medium shadow hover:opacity-90">停止闹钟</button>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
