<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>表盘番茄钟 - 点击选择时间</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; }
    button:focus { outline: none; }
  </style>
</head>
<body class="bg-neutral-100">
  <div id="root"></div>
  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    function App() {
      return (
        <div className="min-h-screen w-full flex items-center justify-center p-6">
          <div className="w-full max-w-[880px] grid md:grid-cols-[420px_1fr] gap-8 items-center">
            <DialTimer />
            <Controls />
          </div>
        </div>
      );
    }

    // ----- A simple global store via context for brevity -----
    const Ctx = React.createContext(null);

    function DialTimerProvider({ children }) {
      const [remainingSec, setRemainingSec] = useState(25 * 60);
      const [running, setRunning] = useState(false);
      const startedAtRef = useRef(null);
      const pausedRemainRef = useRef(remainingSec);
      const tickRef = useRef(null);

      const clearTick = () => {
        if (tickRef.current) cancelAnimationFrame(tickRef.current);
        tickRef.current = null;
      };

      const start = () => {
        if (running) return;
        setRunning(true);
        const now = Date.now();
        startedAtRef.current = now;
        const loop = () => {
          const startedAt = startedAtRef.current;
          if (!startedAt) return;
          const elapsed = Math.floor((Date.now() - startedAt) / 1000);
          const next = Math.max(pausedRemainRef.current - elapsed, 0);
          setRemainingSec(next);
          if (next <= 0) {
            setRunning(false);
            clearTick();
            startedAtRef.current = null;
            pausedRemainRef.current = 0;
            playBeep();
            return;
          }
          tickRef.current = requestAnimationFrame(loop);
        };
        tickRef.current = requestAnimationFrame(loop);
      };

      const pause = () => {
        if (!running) return;
        setRunning(false);
        clearTick();
        startedAtRef.current = null;
        pausedRemainRef.current = remainingSec;
      };

      const reset = (toSec = 25 * 60) => {
        setRunning(false);
        clearTick();
        setRemainingSec(toSec);
        pausedRemainRef.current = toSec;
        startedAtRef.current = null;
      };

      const addFive = () => {
        const added = Math.min(60 * 60, remainingSec + 5 * 60);
        setRemainingSec(added);
        pausedRemainRef.current = added;
      };

      const setByMinutes = (minutes) => {
        // 点击表盘设置起始时间（1..60），0 视为 60
        const m = Math.max(1, Math.min(60, minutes || 60));
        reset(m * 60);
      };

      const mm = String(Math.floor(remainingSec / 60)).padStart(2, "0");
      const ss = String(Math.floor(remainingSec % 60)).padStart(2, "0");

      const store = {
        remainingSec, setRemainingSec,
        running, setRunning,
        start, pause, reset, addFive,
        setByMinutes,
        mm, ss
      };

      useEffect(() => () => clearTick(), []);
      return <Ctx.Provider value={store}>{children}</Ctx.Provider>;
    }

    function DialTimer() {
      const { remainingSec, setByMinutes } = React.useContext(Ctx);
      const size = 420;
      const cx = size / 2;
      const cy = size / 2;
      const r = size * 0.42;
      const ringR = r * 0.98;

      const remainingMinutesForDial = Math.min(remainingSec / 60, 60);

      const sectorPath = useMemo(() => {
        const sweepAngle = (remainingMinutesForDial / 60) * 360;
        if (sweepAngle <= 0) return "";
        const startAngle = -90;
        const endAngle = startAngle + sweepAngle;
        const toXY = (angleDeg) => {
          const rad = (angleDeg * Math.PI) / 180;
          return { x: cx + r * Math.cos(rad), y: cy + r * Math.sin(rad) };
        };
        const p1 = toXY(startAngle);
        const p2 = toXY(endAngle);
        const largeArc = sweepAngle > 180 ? 1 : 0;
        return `M ${cx} ${cy} L ${p1.x} ${p1.y} A ${r} ${r} 0 ${largeArc} 1 ${p2.x} ${p2.y} Z`;
      }, [remainingMinutesForDial, cx, cy, r]);

      const pointerPath = useMemo(() => {
        const sweepAngle = (remainingMinutesForDial / 60) * 360;
        const endAngle = -90 + sweepAngle;
        const rad = (endAngle * Math.PI) / 180;
        const px = cx + r * Math.cos(rad);
        const py = cy + r * Math.sin(rad);
        return `M ${cx} ${cy} L ${px} ${py}`;
      }, [remainingMinutesForDial, cx, cy, r]);

      const ticks = useMemo(() => {
        const list = [];
        const labels = ["0/60", "5", "10", "15", "20", "25", "30", "35", "40", "45", "50", "55"];
        const step = 360 / 12;
        for (let i = 0; i < labels.length; i++) {
          const angle = -90 + step * i;
          const rad = (angle * Math.PI) / 180;
          const x = cx + ringR * Math.cos(rad);
          const y = cy + ringR * Math.sin(rad);
          list.push({ label: labels[i], x, y, key: labels[i] + i });
        }
        return list;
      }, [cx, cy, ringR]);

      const handleDialClick = (e) => {
        const svg = e.currentTarget;
        const rect = svg.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt(dx*dx + dy*dy);
        // 只在接近表盘区域的点击才有效（避免点到外面）
        if (dist > r * 1.1) return;
        // atan2 以 X 轴为基准，顺时针角度：把 12 点作为 0 起点
        const deg = Math.atan2(dy, dx) * 180 / Math.PI; // -180..180，相对于 +X 轴
        let cw = (deg + 90); // 以 12 点为 0
        cw = (cw + 360) % 360; // 0..359.999
        let mins = Math.round(cw / 6); // 每 6° = 1 分钟
        if (mins === 0) mins = 60; // 0 视作 60
        setByMinutes(mins);
      };

      return (
        <div className="bg-white rounded-2xl shadow-lg p-4 flex items-center justify-center select-none">
          <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`} onClick={handleDialClick} className="cursor-pointer">
            <circle cx={cx} cy={cy} r={r} fill="#ffffff" stroke="#e5e7eb" strokeWidth={4} />
            {sectorPath && <path d={sectorPath} fill="#fca5a5" opacity={0.9} />}
            <path d={pointerPath} stroke="#111827" strokeWidth={6} strokeLinecap="round" />
            <circle cx={cx} cy={cy} r={6} fill="#111827" />
            {Array.from({ length: 60 }).map((_, i) => {
              const angle = (-90 + i * 6) * (Math.PI / 180);
              const outer = r;
              const inner = r - (i % 5 === 0 ? 14 : 8);
              const x1 = cx + outer * Math.cos(angle);
              const y1 = cy + outer * Math.sin(angle);
              const x2 = cx + inner * Math.cos(angle);
              const y2 = cy + inner * Math.sin(angle);
              return <line key={i} x1={x1} y1={y1} x2={x2} y2={y2} stroke="#9ca3af" strokeWidth={i % 5 === 0 ? 2 : 1} />;
            })}
            {ticks.map((t) => (
              <text key={t.key} x={t.x} y={t.y} textAnchor="middle" dominantBaseline="central" fontSize={16} fill="#111827">
                {t.label}
              </text>
            ))}
          </svg>
        </div>
      );
    }

    function Controls() {
      const { running, start, pause, reset, addFive, mm, ss } = React.useContext(Ctx);
      return (
        <div className="bg-white rounded-2xl shadow-lg p-6 flex flex-col justify-between min-h-[220px]">
          <div>
            <div className="text-sm text-neutral-500">剩余时间</div>
            <div className="text-6xl font-semibold tracking-wider tabular-nums">{mm}:{ss}</div>
          </div>
          <div className="flex items-center gap-3 mt-6 flex-wrap">
            {!running ? (
              <button onClick={start} className="px-5 py-3 rounded-xl bg-black text-white shadow hover:opacity-90">开始</button>
            ) : (
              <button onClick={pause} className="px-5 py-3 rounded-xl bg-neutral-800 text-white shadow hover:opacity-90">暂停</button>
            )}
            <button onClick={() => reset()} className="px-5 py-3 rounded-xl bg-neutral-200 hover:bg-neutral-300">重置</button>
            <button onClick={addFive} className="px-5 py-3 rounded-xl bg-rose-100 text-rose-700 hover:bg-rose-200">+5 分钟</button>
          </div>
          <div className="text-xs text-neutral-400 mt-4">提示：点击表盘选择起始分钟（1–60）。</div>
        </div>
      );
    }

    function playBeep() {
      try {
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioCtx();
        const now = ctx.currentTime;
        [0, 0.25, 0.5].forEach((offset) => beepOnce(ctx, now + offset));
        setTimeout(() => ctx.close(), 1200);
      } catch (e) {}
    }

    function beepOnce(ctx, when) {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = 880;
      gain.gain.setValueAtTime(0, when);
      gain.gain.linearRampToValueAtTime(0.3, when + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, when + 0.18);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(when);
      osc.stop(when + 0.2);
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<DialTimerProvider><App /></DialTimerProvider>);
  </script>
</body>
</html>
