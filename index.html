<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>è¡¨ç›˜ç•ªèŒ„é’Ÿ - ä¼‘æ¯ä¸¤ç§æ–¹å¼ & è®¡æ•°ç¼–è¾‘å¯å¢åˆ æ”¹</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; }
    button:focus, input:focus, a:focus { outline: none; }
  </style>
</head>
<body class="bg-neutral-100">
  <div id="root"></div>
  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState, useContext } = React;
    const Ctx = React.createContext(null);

    // ====== æ—¥æœŸ & å­˜å‚¨ ======
    function formatLocalDateYYYYMMDD(d = new Date()) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${day}`;
    }
    const COUNTS_PREFIX = "pomodoro_counts_";
    const BREAKS_PREFIX = "pomodoro_breaks_";
    const NAME_KEY = "pomodoro_current_name";
    const SLOGANS_KEY = "pomodoro_break_slogans_v2";

    function loadCountsForToday() {
      const key = COUNTS_PREFIX + formatLocalDateYYYYMMDD();
      try { const raw = localStorage.getItem(key); return raw ? JSON.parse(raw) : {}; } catch { return {}; }
    }
    function saveCountsForToday(obj) {
      const key = COUNTS_PREFIX + formatLocalDateYYYYMMDD();
      try { localStorage.setItem(key, JSON.stringify(obj)); } catch {}
    }
    function loadBreaksForToday() {
      const key = BREAKS_PREFIX + formatLocalDateYYYYMMDD();
      try { const raw = localStorage.getItem(key); const n = raw ? parseInt(raw,10) : 0; return Number.isFinite(n) ? n : 0; } catch { return 0; }
    }
    function saveBreaksForToday(n) {
      const key = BREAKS_PREFIX + formatLocalDateYYYYMMDD();
      try { localStorage.setItem(key, String(Math.max(0, Math.floor(n||0)))); } catch {}
    }

    const DEFAULT_SLOGANS = [
      "è´¢æºæ»šæ»šæ¥ğŸ’°ï¼Œå¾®ç¬‘æ¯ä¸€å¤©ğŸ˜Šâ¤ï¸",
      "æ·±å‘¼å¸ğŸ˜Œï¼Œå‘å¤§è´¢ğŸ’°ï¼Œå¼€å¿ƒğŸ¥°",
      "å¸¸å¾®ç¬‘ğŸ˜ï¼Œå¥½è¿åˆ°ğŸ€ï¼Œç¦æ°”æ»¡â¤ï¸",
      "çˆ±è‡ªå·±â¤ï¸ï¼Œæ·±å‘¼å¸ğŸŒ¬ï¸ï¼Œè´¢è¿æ¥ğŸ’°",
      "ç¬‘å£å¸¸å¼€ğŸ˜„ï¼Œé»„é‡‘ä¸‡ä¸¤ğŸª™â¤ï¸",
      "å¼€å¿ƒç”Ÿè´¢ğŸ’°ï¼Œç¦æ°”æ»¡æ»¡ğŸ€",
      "æ­‡ä¸€æ­‡ğŸ˜‡ï¼Œå†å‘è´¢ğŸ’°ï¼Œå¿ƒæ¬¢å–œâ¤ï¸",
      "ç¦æ»¡ğŸ€ï¼Œç¬‘ç”œğŸ˜‹ï¼Œè´¢æ—ºğŸ’°",
      "æ”¾æ¾ğŸŒ¿ï¼Œå¥½è¿æ¥ğŸ’«ï¼Œçˆ±è‡ªå·±â¤ï¸",
      "ä½ ä¸€ç¬‘ğŸ˜Šï¼Œè´¢ç¥åˆ°ğŸ’°ï¼Œç¦æ»¡å¿ƒâ¤ï¸",
    ];
    function loadSlogans() {
      try { const raw = localStorage.getItem(SLOGANS_KEY); const arr = raw ? JSON.parse(raw) : null; if (Array.isArray(arr) && arr.length) return arr.map(String); } catch {}
      return DEFAULT_SLOGANS.slice();
    }
    function saveSlogans(arr) { try { localStorage.setItem(SLOGANS_KEY, JSON.stringify(arr)); } catch {} }

    // ====== åº”ç”¨ ======
    function App() {
      return (
        <AlarmProvider>
          <div className="min-h-screen w-full flex items-stretch justify-center p-4 md:p-6">
            <div className="w-full grid gap-6 lg:grid-cols-[minmax(420px,1fr)_minmax(540px,1.2fr)] xl:grid-cols-[minmax(520px,1.2fr)_minmax(720px,1.5fr)]">
              <DialTimer />
              <div className="flex flex-col gap-6">
                <PomodoroPanel />
                <CountersPanel />
                <FooterLink />
              </div>
            </div>
          </div>

          <AlarmModal />
          <SlogansModal />
        </AlarmProvider>
      );
    }

    function AlarmProvider({ children }) {
      const [remainingSec, setRemainingSec] = useState(25 * 60);
      const [running, setRunning] = useState(false);
      const [alarmActive, setAlarmActive] = useState(false);
      const [currentName, setCurrentName] = useState(localStorage.getItem(NAME_KEY) || "æœªå‘½å");
      const [todayCounts, setTodayCounts] = useState(loadCountsForToday());
      const [breakCount, setBreakCount] = useState(loadBreaksForToday());
      const [isBreak, setIsBreak] = useState(false);

      // ä¼‘æ¯å£å·
      const [slogans, setSlogans] = useState(loadSlogans());
      const [slogansOpen, setSlogansOpen] = useState(false);

      const prevNameRef = useRef(currentName);
      const dialCustomSetRef = useRef(false);

      const startedAtRef = useRef(null);
      const pausedRemainRef = useRef(remainingSec);
      const tickRef = useRef(null);

      // WebAudioï¼ˆæ›´å¤§éŸ³é‡ï¼‰
      const audioCtxRef = useRef(null);
      const alarmIntervalRef = useRef(null);
      const masterGainRef = useRef(null);

      const ensureAudioContext = () => {
        if (!audioCtxRef.current) {
          const AudioCtx = window.AudioContext || window.webkitAudioContext;
          audioCtxRef.current = new AudioCtx();
          masterGainRef.current = audioCtxRef.current.createGain();
          masterGainRef.current.gain.value = 1.5;
          masterGainRef.current.connect(audioCtxRef.current.destination);
        } else {
          audioCtxRef.current.resume?.();
        }
      };

      const clearTick = () => { if (tickRef.current) cancelAnimationFrame(tickRef.current); tickRef.current = null; };

      const startWithDuration = (sec) => {
        const dur = Math.max(1, Math.floor(sec || 0));
        setRunning(true);
        pausedRemainRef.current = dur;
        setRemainingSec(dur);
        startedAtRef.current = Date.now();
        const loop = () => {
          const elapsed = Math.floor((Date.now() - startedAtRef.current) / 1000);
          const next = Math.max(pausedRemainRef.current - elapsed, 0);
          setRemainingSec(next);
          if (next <= 0) {
            setRunning(false); clearTick(); startedAtRef.current = null; pausedRemainRef.current = 0;
            handleSessionEnd();
            return;
          }
          tickRef.current = requestAnimationFrame(loop);
        };
        tickRef.current = requestAnimationFrame(loop);
      };

      const start = () => {
        if (running) return;
        setIsBreak(false);
        startWithDuration(pausedRemainRef.current || remainingSec);
      };

      const pause = () => { setRunning(false); clearTick(); startedAtRef.current = null; pausedRemainRef.current = remainingSec; };

      const setExactSeconds = (sec) => {
        const s = Math.max(1, Math.floor(sec || 0));
        setRunning(false); clearTick();
        setRemainingSec(s); pausedRemainRef.current = s; startedAtRef.current = null;
        setIsBreak(false);
      };

      const reset = (toSec = 25*60) => {
        setRunning(false); clearTick();
        setRemainingSec(toSec); pausedRemainRef.current = toSec; startedAtRef.current = null;
        setIsBreak(false);
      };

      const addFive = () => { const added = Math.min(3600, remainingSec + 300); setRemainingSec(added); pausedRemainRef.current = added; };

      const setByMinutes = (m) => {
        const sec = Math.max(60, Math.min(3600, (m || 60) * 60));
        reset(sec);
        dialCustomSetRef.current = true;
      };

      // åç§°ï¼šå…è®¸åˆ ç©ºï¼Œç©ºåˆ™å½’ä¸ºâ€œæœªå‘½åâ€
      const setName = (n) => {
        const v = (n || "").trim();
        const finalName = v ? v : "æœªå‘½å";
        setCurrentName(finalName);
        try { localStorage.setItem(NAME_KEY, finalName); } catch {}
      };

      // â€œä¼‘æ¯â€ä¸¤ç§æ–¹å¼é€»è¾‘
      const startBreak = () => {
        prevNameRef.current = (currentName || "").trim() || "æœªå‘½å";
        setIsBreak(true);
        const list = (slogans && slogans.length ? slogans : DEFAULT_SLOGANS);
        const chosen = list[Math.floor(Math.random() * list.length)];
        setCurrentName(chosen);
        try { localStorage.setItem(NAME_KEY, prevNameRef.current); } catch {}
        const duration = dialCustomSetRef.current ? remainingSec : 5 * 60; // æ–¹å¼2ï¼šå…ˆé€‰è¡¨ç›˜æ—¶é—´ï¼Œå†ä¼‘æ¯
        dialCustomSetRef.current = false;
        startWithDuration(duration);
      };

      // ç»“æŸå¤„ç†
      const handleSessionEnd = () => {
        if (!isBreak) {
          const counts = { ...loadCountsForToday() };
          const key = ((currentName || "").trim()) || "æœªå‘½å";
          counts[key] = (counts[key] || 0) + 1;
          saveCountsForToday(counts);
          setTodayCounts(counts);
        } else {
          // ä¼‘æ¯ï¼šä¸äº§ç”Ÿç•ªèŒ„è®¡æ•°ï¼Œåªç´¯è®¡ä¼‘æ¯æ¬¡æ•°
          setCurrentName(prevNameRef.current);
          try { localStorage.setItem(NAME_KEY, prevNameRef.current); } catch {}
          setIsBreak(false);
          const newBreaks = (loadBreaksForToday() || 0) + 1;
          saveBreaksForToday(newBreaks);
          setBreakCount(newBreaks);
        }
        triggerAlarm();
        setRemainingSec(25 * 60);
        pausedRemainRef.current = 25 * 60;
        setRunning(false);
      };

      const triggerAlarm = () => { ensureAudioContext(); startAlarmLoop(); setAlarmActive(true); };
      const stopAlarm = () => { setAlarmActive(false); stopAlarmLoop(); };
      const startAlarmLoop = () => {
        stopAlarmLoop(); ensureAudioContext();
        const ctx = audioCtxRef.current, master = masterGainRef.current;
        const play = () => { if (!ctx) return; beepOnce(ctx, master, 0, 1100); beepOnce(ctx, master, 0.32, 1300); };
        play(); alarmIntervalRef.current = setInterval(play, 1200);
      };
      const stopAlarmLoop = () => { if (alarmIntervalRef.current) { clearInterval(alarmIntervalRef.current); alarmIntervalRef.current = null; } };

      const replaceTodayCounts = (obj) => { saveCountsForToday(obj); setTodayCounts(obj); };
      const setBreaksToday = (n) => { const v = Math.max(0, Math.floor(Number(n)||0)); saveBreaksForToday(v); setBreakCount(v); };

      useEffect(() => { saveSlogans(slogans); }, [slogans]);

      useEffect(() => () => {
        clearTick(); stopAlarmLoop();
        if (audioCtxRef.current) { audioCtxRef.current.close(); audioCtxRef.current = null; masterGainRef.current = null; }
      }, []);

      const mm = String(Math.floor(remainingSec / 60)).padStart(2, "0");
      const ss = String(Math.floor(remainingSec % 60)).padStart(2, "0");

      return (
        <Ctx.Provider value={{
          remainingSec, running, alarmActive, currentName, todayCounts, breakCount, mm, ss, isBreak,
          start, pause, reset, addFive, setByMinutes, setExactSeconds, setName, stopAlarm, startBreak,
          replaceTodayCounts, setBreaksToday,
          slogans, setSlogans, slogansOpen, setSlogansOpen
        }}>
          {children}
        </Ctx.Provider>
      );
    }

    function beepOnce(ctx, masterGain, offsetSec, freq = 1000) {
      const now = ctx.currentTime + offsetSec;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.exponentialRampToValueAtTime(1.0, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.32);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(now);
      osc.stop(now + 0.34);
    }

    // ====== è¡¨ç›˜ï¼ˆçº¯çº¢ï¼›è‡ªé€‚åº”ï¼‰ ======
    function DialTimer() {
      const { remainingSec, setByMinutes } = useContext(Ctx);
      const computeSize = () => Math.max(360, Math.min(800, Math.floor(window.innerWidth * 0.4)));
      const [size, setSize] = useState(computeSize());
      useEffect(() => { const onResize = () => setSize(computeSize()); window.addEventListener('resize', onResize); return () => window.removeEventListener('resize', onResize); }, []);

      const cx = size/2, cy = size/2, r = size * 0.42, ringR = r * 0.98;
      const remainingMinutesForDial = Math.min(remainingSec / 60, 60);

      const sectorPath = React.useMemo(() => {
        const sweepAngle = (remainingMinutesForDial / 60) * 360;
        if (sweepAngle <= 0) return "";
        const startAngle = -90, endAngle = startAngle + sweepAngle;
        const toXY = (deg) => { const rad = (deg * Math.PI) / 180; return { x: cx + r * Math.cos(rad), y: cy + r * Math.sin(rad) }; };
        const p1 = toXY(startAngle), p2 = toXY(endAngle);
        const largeArc = sweepAngle > 180 ? 1 : 0;
        return `M ${cx} ${cy} L ${p1.x} ${p1.y} A ${r} ${r} 0 ${largeArc} 1 ${p2.x} ${p2.y} Z`;
      }, [remainingMinutesForDial, cx, cy, r]);

      const pointerPath = React.useMemo(() => {
        const sweepAngle = (remainingMinutesForDial / 60) * 360;
        const endAngle = -90 + sweepAngle;
        const rad = (endAngle * Math.PI) / 180;
        const px = cx + r * Math.cos(rad);
        const py = cy + r * Math.sin(rad);
        return `M ${cx} ${cy} L ${px} ${py}`;
      }, [remainingMinutesForDial, cx, cy, r]);

      const ticks = React.useMemo(() => {
        const labels = ["60","5","10","15","20","25","30","35","40","45","50","55"];
        const step = 360 / 12;
        return labels.map((label, i) => {
          const angle = -90 + step * i;
          const rad = (angle * Math.PI) / 180;
          return { label, x: cx + ringR * Math.cos(rad), y: cy + ringR * Math.sin(rad) };
        });
      }, [cx, cy, r, ringR]);

      const handleDialClick = (e) => {
        const svg = e.currentTarget;
        const rect = svg.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist > r * 1.1) return;
        const deg = Math.atan2(dy, dx) * 180 / Math.PI;
        let cw = (deg + 90 + 360) % 360;
        let mins = Math.round(cw / 6);
        if (mins === 0) mins = 60;
        setByMinutes(mins);
      };

      return (
        <div className="bg-white rounded-2xl shadow-lg p-4 flex items-center justify-center select-none w-full">
          <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`} onClick={handleDialClick} className="cursor-pointer">
            <circle cx={cx} cy={cy} r={r} fill="#ffffff" stroke="#e5e7eb" strokeWidth={4} />
            {sectorPath && <path d={sectorPath} fill="#ff0000" opacity={0.9} />}
            <path d={pointerPath} stroke="#111827" strokeWidth={6} strokeLinecap="round" />
            <circle cx={cx} cy={cy} r={6} fill="#111827" />
            {Array.from({ length: 60 }).map((_, i) => {
              const angle = (-90 + i * 6) * (Math.PI / 180);
              const outer = r;
              const inner = r - (i % 5 === 0 ? 14 : 8);
              const x1 = cx + outer * Math.cos(angle);
              const y1 = cy + outer * Math.sin(angle);
              const x2 = cx + inner * Math.cos(angle);
              const y2 = cy + inner * Math.sin(angle);
              return <line key={i} x1={x1} y1={y1} x2={x2} y2={y2} stroke="#9ca3af" strokeWidth={i % 5 === 0 ? 2 : 1} />;
            })}
            {/* 12å¤§åˆ»åº¦æ ‡æ³¨ */}
            {(() => {
              const labels = ["60","5","10","15","20","25","30","35","40","45","50","55"];
              const step = 360 / 12;
              return labels.map((label, i) => {
                const angle = -90 + step * i;
                const rad = (angle * Math.PI) / 180;
                const ringR = (i % 5 === 0 ? r - 14 : r - 8) - 16;
                const x = cx + ringR * Math.cos(rad);
                const y = cy + ringR * Math.sin(rad);
                return <text key={i} x={x} y={y} textAnchor="middle" dominantBaseline="central" fontSize={16} fill="#111827">{label}</text>;
              });
            })()}
          </svg>
        </div>
      );
    }

    // ====== ç•ªèŒ„æ§åˆ¶å¡ ======
    function PomodoroPanel() {
      const { running, start, pause, reset, addFive, currentName, setName, startBreak, mm, ss } = useContext(Ctx);
      return (
        <div className="bg-white rounded-2xl shadow-lg p-6 flex flex-col gap-6 w-full">
          <div className="w-full">
            <div className="text-sm text-neutral-500">å½“å‰ç•ªèŒ„é’Ÿ</div>
            <PomodoroNameInput />
            <EditableTime />
          </div>

          <div className="flex items-center gap-3 flex-wrap">
            {!running ? (
              <button onClick={start} className="px-5 py-3 rounded-xl bg-black text-white shadow hover:opacity-90">å¼€å§‹</button>
            ) : (
              <button onClick={pause} className="px-5 py-3 rounded-xl bg-neutral-800 text-white shadow hover:opacity-90">æš‚åœ</button>
            )}
            <button onClick={() => reset()} className="px-5 py-3 rounded-xl bg-neutral-200 hover:bg-neutral-300">é‡ç½®</button>
            <button onClick={addFive} className="px-5 py-3 rounded-xl bg-rose-100 text-rose-700 hover:bg-rose-200">+5 åˆ†é’Ÿ</button>
            <button onClick={startBreak} className="px-5 py-3 rounded-xl bg-slate-100 text-slate-700 hover:bg-slate-200">ä¼‘æ¯</button>
          </div>
        </div>
      );
    }

    
    // ====== å¯ç¼–è¾‘ä¸­å¿ƒæ—¶é—´ï¼ˆMM:SSï¼Œæœ€å° 1sï¼‰ ======
    function EditableTime() {
      const { remainingSec, setExactSeconds } = useContext(Ctx);
      const [editing, setEditing] = React.useState(false);
      const [val, setVal] = React.useState(format(remainingSec));
      const inputRef = React.useRef(null);

      React.useEffect(() => {
        if (!editing) setVal(format(remainingSec));
      }, [remainingSec, editing]);

      React.useEffect(() => {
        if (editing && inputRef.current) {
          inputRef.current.focus();
          inputRef.current.select();
        }
      }, [editing]);

      function format(sec) {
        const s = Math.max(0, Math.floor(sec || 0));
        const mm = String(Math.floor(s / 60)).padStart(2, "0");
        const ss = String(s % 60).padStart(2, "0");
        return mm + ":" + ss;
      }

      function parseToSeconds(text) {
        const t = (text || "").trim();
        // Accept M:S or MM:SS; also allow just seconds "SS" or "S"
        if (t.includes(":")) {
          const parts = t.split(":");
          if (parts.length !== 2) return null;
          let m = parseInt(parts[0], 10);
          let s = parseInt(parts[1], 10);
          if (!Number.isFinite(m) || !Number.isFinite(s) || s < 0 || s > 59 || m < 0) return null;
          return m * 60 + s;
        } else {
          // if only number, treat as seconds for flexibility
          let s = parseInt(t, 10);
          if (!Number.isFinite(s) || s < 0) return null;
          return s;
        }
      }

      const commit = () => {
        const secs = parseToSeconds(val);
        if (secs === null) {
          // revert
          setVal(format(remainingSec));
          setEditing(false);
          return;
        }
        const clamped = Math.max(1, Math.floor(secs)); // min 1s
        setExactSeconds(clamped);
        setVal(format(clamped));
        setEditing(false);
      };

      const onKeyDown = (e) => {
        if (e.key === "Enter") { e.preventDefault(); commit(); }
        if (e.key === "Escape") { e.preventDefault(); setVal(format(remainingSec)); setEditing(false); }
      };

      if (!editing) {
        return (
          <div
            className="mt-3 text-5xl font-semibold tracking-wider tabular-nums cursor-text select-none"
            title="ç‚¹å‡»ç¼–è¾‘ï¼Œæ”¯æŒæœ€å° 1 ç§’ï¼ˆMM:SS æˆ– çº¯ç§’æ•°ï¼‰"
            onClick={() => setEditing(true)}
          >
            {format(remainingSec)}
          </div>
        );
      }

      return (
        <input
          ref={inputRef}
          className="mt-3 text-5xl font-semibold tracking-wider tabular-nums px-2 rounded-md border border-neutral-200 focus:ring-2 focus:ring-neutral-800 w-[10.5ch]"
          value={val}
          onChange={(e) => setVal(e.target.value)}
          onBlur={commit}
          onKeyDown={onKeyDown}
          placeholder="MM:SS"
          inputMode="numeric"
        />
      );
    }

    // ====== å½“å‰ç•ªèŒ„é’Ÿåç§°è¾“å…¥ï¼ˆç¼“å†²ï¼Œå¤±ç„¦/Enter ä¿å­˜ï¼ŒEsc è¿˜åŸï¼‰ ======
    function PomodoroNameInput() {
      const { currentName, setName } = useContext(Ctx);
      const [draft, setDraft] = React.useState(currentName);
      const inputRef = React.useRef(null);

      React.useEffect(() => { setDraft(currentName); }, [currentName]);

      const commit = () => {
        const v = (draft || "").trim();
        setName(v); // setName ä¼šæŠŠç©ºåå½’ä¸ºâ€œæœªå‘½åâ€å¹¶æŒä¹…åŒ–
      };

      const onKeyDown = (e) => {
        if (e.key === "Enter") { e.preventDefault(); commit(); e.currentTarget.blur(); }
        if (e.key === "Escape") { e.preventDefault(); setDraft(currentName); e.currentTarget.blur(); }
      };

      return (
        <input
          ref={inputRef}
          className="mt-1 w-full text-2xl font-semibold px-3 py-2 rounded-xl border border-neutral-200 focus:ring-2 focus:ring-neutral-800"
          value={draft}
          onChange={(e) => setDraft(e.target.value)}
          onBlur={commit}
          onKeyDown={onKeyDown}
          placeholder="å¯è¾“å…¥åç§°ï¼›æ¸…ç©ºåè‡ªåŠ¨å½’ä¸ºâ€œæœªå‘½åâ€"
        />
      );
    }
// ====== è®¡æ•°å¡ï¼ˆç¼–è¾‘å¯å¢åˆ æ”¹ï¼Œå«ä¼‘æ¯æ¬¡æ•°ï¼‰ ======
    function CountersPanel() {
      const { todayCounts, breakCount, replaceTodayCounts, setBreaksToday, setName } = useContext(Ctx);
      const [editing, setEditing] = useState(false);
      const [draft, setDraft] = useState([]); // includes rest row when editing

      const totalCount = useMemo(() => {
        return Object.values(todayCounts || {}).reduce((sum, v) => sum + (Number(v)||0), 0);
      }, [todayCounts]);

      useEffect(() => {
        if (editing) {
          const arr = Object.entries(todayCounts).map(([name, count]) => ({ name, count: Number(count)||0 }));
          arr.push({ name: "ä¼‘æ¯æ¬¡æ•°", count: Number(breakCount)||0 });
          setDraft(arr);
        } else {
          setDraft([]);
        }
      }, [editing, todayCounts, breakCount]);

      const sortedDisplay = (entries) => [...entries].sort((a, b) => (b.count || 0) - (a.count || 0));

      const saveDraft = () => {
        const map = {};
        let breaks = 0;
        for (const { name, count } of draft) {
          let nm = (name || "").trim();
          const ct = Math.max(0, Math.floor(Number(count) || 0));
          if (nm === "ä¼‘æ¯æ¬¡æ•°") {
            // ä¼‘æ¯æ¬¡æ•°ï¼šå…è®¸æ”¹æ•°é‡ï¼›åˆ é™¤è¡Œ=ä¸å†™å…¥ï¼ˆè®¡ä¸º0ï¼‰
            breaks = ct;
            continue;
          }
          if (ct <= 0) {
            // 0 å€¼ç›´æ¥å¿½ç•¥ï¼ˆåˆ é™¤ï¼‰
            continue;
          }
          if (!nm) {
            // ç©ºåå½’ä¸ºâ€œæœªå‘½åâ€
            nm = "æœªå‘½å";
          }
          map[nm] = (map[nm] || 0) + ct; // é‡ååˆå¹¶
        }
        replaceTodayCounts(map);
        setBreaksToday(breaks);
      };

      const toggleEditing = () => {
        if (editing) { saveDraft(); setEditing(false); } else { setEditing(true); }
      };

      const clearAllPomodorosLink = (e) => {
        e.preventDefault();
        const rest = draft.find(r => r.name === "ä¼‘æ¯æ¬¡æ•°");
        setDraft(rest ? [{ ...rest }] : [{ name: "ä¼‘æ¯æ¬¡æ•°", count: 0 }]);
      };

      const addRow = () => setDraft([...draft, { name: "", count: 1 }]); // æ–°å¢æ¡ç›®

      return (
        <div className="bg-white rounded-2xl shadow-lg p-6 w-full">
          <div className="flex items-center justify-between">
            <div className="text-sm text-neutral-600">
              ä»Šæ—¥è®¡æ•°ï¼š<span className="tabular-nums">{totalCount}</span> ï¼ˆ{formatLocalDateYYYYMMDD()}ï¼‰
            </div>
            <button title={editing ? "ä¿å­˜" : "ç¼–è¾‘"} onClick={toggleEditing} className="opacity-30 hover:opacity-60 transition text-neutral-600" aria-label={editing ? "ä¿å­˜" : "ç¼–è¾‘"}>
              {editing ? (
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M20 6L9 17l-5-5" /></svg>
              ) : (
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 20h9" /><path d="M16.5 3.5l4 4L7 21H3v-4L16.5 3.5z" /></svg>
              )}
            </button>
          </div>

          {/* åˆ—è¡¨ï¼ˆæŸ¥çœ‹æ¨¡å¼ä¸å±•ç¤ºä¼‘æ¯æ¬¡æ•°è¡Œï¼‰ */}
          <div className="mt-3 grid gap-2">
            {Object.keys(todayCounts).length === 0 && !editing ? (
              <div className="text-neutral-400 text-sm">ä»Šæ—¥æš‚æ— çº¿ç¨‹è®°å½•ã€‚</div>
            ) : editing ? (
              sortedDisplay(draft).map((row, idx) => (
                <EditableRow
                  key={idx + row.name + idx}
                  name={row.name}
                  count={row.count}
                  lockName={row.name === "ä¼‘æ¯æ¬¡æ•°"}  /* ä¼‘æ¯æ¬¡æ•°ï¼šé”å®šåç§°ï¼Œä»…å¯æ”¹æ•°é‡/å¯åˆ  */
                  onChange={(newName, newCount) => {
                    const next = [...draft];
                    next[idx] = { name: newName, count: newCount };
                    setDraft(next);
                  }}
                  onDelete={() => {
                    const next = [...draft];
                    next.splice(idx, 1);
                    setDraft(next);
                  }}
                />
              ))
            ) : (
              sortedDisplay(Object.entries(todayCounts).map(([name, count]) => ({ name, count }))).map(({name, count}) => (
                <div key={name} className="flex items-center justify-between bg-neutral-50 px-4 py-2 rounded-lg">
                  <button
                    className="font-medium truncate pr-4 text-left hover:underline"
                    title="ç‚¹å‡»å°†è¯¥åç§°å¡«å…¥å½“å‰ç•ªèŒ„é’Ÿ"
                    onClick={() => setName(name)}
                  >
                    {name}
                  </button>
                  <div className="tabular-nums">{count}</div>
                </div>
              ))
            )}
          </div>

          {/* ä¼‘æ¯æ¬¡æ•°ï¼ˆä»Šå¤©æ€»æ•°ï¼‰â€”â€”æŸ¥çœ‹æ¨¡å¼å±…ä¸­ */}
          {!editing && (
            <div className="mt-4 text-neutral-700 text-sm text-center">
              ä¼‘æ¯æ¬¡æ•°ï¼š<span className="tabular-nums">{breakCount}</span>
            </div>
          )}

          {/* ç¼–è¾‘æ¨¡å¼åº•éƒ¨å·¥å…·è¡Œ */}
          {editing && (
            <div className="mt-3 flex items-center justify-between gap-3">
              <div className="flex items-center gap-3">
                <button className="text-xs px-3 py-2 rounded-lg bg-neutral-100 hover:bg-neutral-200 text-neutral-700" onClick={addRow}>æ–°å¢ä¸€æ¡</button>
                <a href="#" onClick={clearAllPomodorosLink} className="text-xs text-neutral-400 hover:text-neutral-700 underline decoration-dotted">æ¸…é›¶æ¬¡æ•°</a>
              </div>
              <div className="text-xs text-neutral-400">0 å€¼/ç©ºåå¿½ç•¥ï¼›é‡ååˆå¹¶ï¼›åˆ é™¤=è®¾ä¸º 0ã€‚</div>
            </div>
          )}
        </div>
      );
    }

    function EditableRow({ name, count, lockName=false, onChange, onDelete }) {
      const [nameVal, setNameVal] = useState(name);
      const [countVal, setCountVal] = useState(String(count));
      useEffect(() => setNameVal(name), [name]);
      useEffect(() => setCountVal(String(count)), [count]);

      return (
        <div className="flex items-center justify-between bg-neutral-50 px-3 py-2 rounded-lg gap-3">
          <input
            className={`flex-1 min-w-0 px-2 py-1 rounded-md border border-neutral-200 ${lockName ? 'bg-neutral-100 text-neutral-500 cursor-not-allowed' : ''}`}
            value={nameVal}
            onChange={(e) => { if (lockName) return; setNameVal(e.target.value); onChange(e.target.value, countVal); }}
            placeholder="ä»»åŠ¡åç§°ï¼ˆå¯å†™ï¼šä¼‘æ¯æ¬¡æ•°ï¼‰"
            readOnly={lockName}
            aria-readonly={lockName}
          />
          <input className="w-24 text-right px-2 py-1 rounded-md border border-neutral-200 tabular-nums" value={countVal} onChange={(e) => { setCountVal(e.target.value); onChange(nameVal, e.target.value); }} inputMode="numeric" pattern="[0-9]*" />
          <button className="px-2 py-1 rounded-md bg-rose-100 text-rose-700 hover:bg-rose-200" onClick={onDelete}>åˆ é™¤</button>
        </div>
      );
    }

    // ====== åº•éƒ¨â€œä¼‘æ¯å£å·â€å…¥å£ï¼ˆå±…ä¸­ï¼‰ & ç¼–è¾‘æ¨¡æ€æ¡† ======
    function FooterLink() {
      const { setSlogansOpen } = useContext(Ctx);
      return (
        <div className="w-full flex items-center justify-center -mt-2">
          <a href="#" className="text-xs text-neutral-500 hover:text-neutral-800 underline decoration-dotted" onClick={(e) => { e.preventDefault(); setSlogansOpen(true); }}>
            ä¼‘æ¯å£å·
          </a>
        </div>
      );
    }

    function SlogansModal() {
      const { slogans, setSlogans, slogansOpen, setSlogansOpen } = useContext(Ctx);
      const [draft, setDraft] = useState(slogans);

      useEffect(() => { if (slogansOpen) setDraft(slogans); }, [slogansOpen, slogans]);

      if (!slogansOpen) return null;

      const addRow = () => setDraft([...(draft || []), ""]);
      const delRow = (idx) => { const next = [...draft]; next.splice(idx, 1); setDraft(next); };
      const commit = () => {
        const cleaned = (draft || []).map(s => (s || "").trim()).filter(Boolean);
        setSlogans(cleaned.length ? cleaned : DEFAULT_SLOGANS.slice());
        setSlogansOpen(false);
      };
      const cancel = () => setSlogansOpen(false);

      return (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/50 backdrop-blur-sm" onClick={cancel}></div>
          <div className="absolute inset-0 flex items-center justify-center p-4">
            <div className="bg-white w-full max-w-lg rounded-2xl shadow-2xl p-6">
              <div className="text-lg font-semibold">ç¼–è¾‘ä¼‘æ¯å£å·</div>
              <div className="mt-3 grid gap-2 max-h-[60vh] overflow-auto pr-1">
                {(draft || []).map((s, i) => (
                  <div key={i} className="flex items-center gap-2">
                    <input className="flex-1 min-w-0 px-2 py-1 rounded-md border border-neutral-200" value={s} onChange={(e) => {
                      const next = [...draft]; next[i] = e.target.value; setDraft(next);
                    }} />
                    <button className="px-2 py-1 rounded-md bg-rose-100 text-rose-700 hover:bg-rose-200" onClick={() => delRow(i)} aria-label="åˆ é™¤">åˆ </button>
                  </div>
                ))}
                <div className="text-right">
                  <button className="text-xs px-3 py-2 rounded-lg bg-neutral-100 hover:bg-neutral-200 text-neutral-700" onClick={addRow}>æ–°å¢ä¸€æ¡</button>
                </div>
              </div>

              <div className="mt-4 flex items-center justify-end gap-3">
                <button className="px-4 py-2 rounded-lg bg-neutral-100 hover:bg-neutral-200" onClick={cancel}>å–æ¶ˆ</button>
                <button className="px-4 py-2 rounded-lg bg-black text-white hover:opacity-90" onClick={commit}>ä¿å­˜</button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    // ====== å¼¹çª— ======
    function AlarmModal() {
      const { alarmActive, stopAlarm } = useContext(Ctx);
      if (!alarmActive) return null;
      return (
        <div className="fixed inset-0 z-50">
          <div className="absolute inset-0 bg-black/50 backdrop-blur-sm"></div>
          <div className="absolute inset-0 flex items-center justify-center p-4">
            <div className="bg-white w-full max-w-md rounded-2xl shadow-2xl p-6 text-center">
              <div className="text-2xl font-semibold">æ—¶é—´åˆ°ï¼</div>
              <div className="mt-2 text-neutral-600">é—¹é’Ÿæ­£åœ¨å¾ªç¯æ’­æ”¾ï¼Œç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åœæ­¢</div>
              <button onClick={stopAlarm} className="mt-6 px-6 py-3 rounded-xl bg-rose-600 text-white font-medium shadow hover:opacity-90">åœæ­¢é—¹é’Ÿ</button>
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
  </script>
</body>
</html>
